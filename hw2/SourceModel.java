import java.util.Arrays;
import java.util.Scanner;
import java.io.File;
import java.io.File.*;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class SourceModel {

	public final static char[] LETTERS = 
		{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
	
	private String SourceName;
	private static double[][][] probGrid =new double[LETTERS.length][LETTERS.length][LETTERS.length];
	
	public static void main(String[] args) throws IOException {
		SourceModel[] models = new SourceModel[(args.length)-1];	
		double[] modelProbability = new double[args.length-1];
		double sumCorpus = 0;

		//Populate Array of source Models and another array of probabilities
		for (int x=0; x<args.length-1;x++) {
 			models[x] = new SourceModel(args[x].substring(0,args[x].indexOf(".")),args[x]);
 			modelProbability[x]=models[x].probability(args[args.length-1]);
 			sumCorpus+=modelProbability[x];
		};
		
		System.out.println("Analyzing: " + args[args.length-1]);
		
		//calculate the max probability
		double maxValue = 0;
		int maxPos = 0;
		for (int x=0; x<modelProbability.length; x++) {
			System.out.println("Probability that test string is " + args[x].substring(0,args[x].indexOf(".")) +" : " + modelProbability[x]/sumCorpus);
			if (modelProbability[x]>maxValue) {
				maxValue = modelProbability[x];
				maxPos = x;
				
			}
		}
		System.out.println("Test string is most likely from corpous "+ args[maxPos].substring(0, args[maxPos].indexOf(".")));
		//System.out.println(models[0].toString());
		
	};

	

	private static int getRank(String singleLetter) {
		return new String(LETTERS).indexOf(singleLetter);		
	};
	
	private static String convertString(String convertFile) {
		return convertFile.toLowerCase().replaceAll("\\s", "").replaceAll("[^a-zA-Z]", "");
	};
	
	public String getName() {
		return SourceName;
	};
	
	public void setName(String SourceName) {
		this.SourceName = SourceName; 
	};
	
	public double probability(String test) {
		//indicates the probability that the test string was generated by the source model
		//using the transition probability matrix created in the constructor
		test = convertString(test);
		//cat
		double probability =(double) 1.0;
		for (int i=2; i< test.length(); i++) {
	
			probability = probability * probGrid[getRank(test.substring(i-2,i-1))][getRank(test.substring(i-1,i))][getRank(test.substring(i,i+1))];
			//System.out.println("Probability of"+ test.substring(i-1,i+1)+  " is "+ probGrid[getRank(test.substring(i-1,i))][getRank(test.substring(i,i+1))]);
			//System.out.println(probability);
				
			};
		return probability;
	};
	
	public String toString() {
		System.out.println("Probability Grid Below");
		String wholeString ="" ; 
		for (int a=0; a< probGrid.length ; a++){ 
			for (int b=0; b < probGrid[a].length ; b++) {
				for (int c=0; c<probGrid[a][b].length;c++) {
					wholeString += Double.toString(probGrid[a][b][c]) + " ";

				}
				wholeString+="\n"; 

			}
		}
		return wholeString;
		
	};
	public static String convertCorpusFile (String corpusFile) throws IOException {
		try {
			FileReader fileReaderInput = new FileReader(corpusFile); //INT VALUES	REPRESENTING A STRING
			String massiveString = "";
			int value = 0;
			
			while (value != -1){
				value = fileReaderInput.read();
				if (value !=-1) {
					String aChar = Character.toString((char)value); //converting Int to Char to String
					massiveString += aChar;
 				}
			};
		fileReaderInput.close();
	 
		return convertString(massiveString);
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
		return "";
	}
	public SourceModel(String modelName, String corpusFile) throws IOException{ //model name is French, train on corpus French 
		String finalFile = convertCorpusFile(corpusFile);
		
		double[][][] grid = new double[LETTERS.length][LETTERS.length][LETTERS.length];
		System.out.print("Training "+ modelName + " model...");
		
		//The row is the for the previous character, the col is for the current character.
		char[] testFileArray = finalFile.toCharArray();
		for(int x=2; x<testFileArray.length;x++) {
			//if statement checks for the first letter of the file, because there's no x-1 letter
			/*if (x==0) {
				//current char				
				int aPos = getRank(Character.toString(testFileArray[0]));
				grid[currentPos][currentPos] = 1;
			}*/
			//go through each (x-1, x) combination and update the count within grid 
			
			int aPos = getRank(Character.toString(testFileArray[x-2]));
			int bPos = getRank(Character.toString(testFileArray[x-1]));
			int cPos = getRank(Character.toString(testFileArray[x]));
			grid[aPos][bPos][cPos]++;
				
		} 
		
		//for loop goes through columns for a given row and gets the total count of that row
		//results are populated in rowCount array
		
		double[][] cCount = new double[LETTERS.length][LETTERS.length];
		for (int a=0; a< LETTERS.length ; a++){ 
			for (int b=0; b < LETTERS.length; b++) {
				for (int c=0; c<LETTERS.length;c++){
					cCount[a][b]+=grid[a][b][c];
				}
			}
		}
		
		
		//divide each count by the sum of all the counts in a row
		for (int a=0; a< LETTERS.length ; a++){ //go through all the rows (previous letter)
			for (int b=0; b < LETTERS.length; b++) { //then go through each column for a given row (current letters)
				for (int c=0; c<LETTERS.length; c++) {
					probGrid[a][b][c] = grid[a][b][c]/cCount[a][b];
					if (Double.isNaN(probGrid[a][b][c])|| probGrid[a][b][c]==0){
						probGrid[a][b][c]=(double) 0.00001;
					}
				}
				
			}
		
		}
		
		
		
		//print done
		System.out.print("done");
		System.out.println();
				
	} //close SourceModel constructor 

} //close class
	


